// Практическая 7.cpp : Этот файл содержит функцию "main". Здесь начинается и заканчивается выполнение программы.
//

#include <stdio.h>
#include <conio.h>

int main(void)
{

    // 1 задача 


    //int x = 3, a = 1, b = 5;
    //int result = 0;

    //__asm
    //{
    //    // сохранение регистров
    //    push eax
    //    push ebx
    //    push ecx
    //    push edx

    //    // вычисление x^2 - a*x
    //    mov eax, x
    //    imul eax, x  // eax = x^2
    //    mov ebx, a
    //    imul ebx, x  // ebx = a*x
    //    sub eax, ebx // eax = x^2 - a*x

    //    // деление (x^2 - a*x) / (b + 2)
    //    cdq          // расширение знака для деления
    //    mov ebx, b
    //    add ebx, 2   // ebx = b + 2
    //    idiv ebx     // eax = (x^2 - a*x) / (b + 2)

    //    // сохранение промежуточного результата
    //    mov ecx, eax // ecx = (x^2 - a*x) / (b + 2)

    //    // вычисление x^3
    //    mov eax, x
    //    imul eax, x  // eax = x^2
    //    imul eax, x  // eax = x^3

    //    // деление x^3 / 3
    //    cdq
    //    mov ebx, 3
    //    idiv ebx     // eax = x^3 / 3

    //    // вычитание (x^3 / 3) из промежуточного результата
    //    sub ecx, eax // ecx = (x^2 - a*x) / (b + 2) - x^3 / 3

    //    // вычисление a^2 * x
    //    mov eax, a
    //    imul eax, a  // eax = a^2
    //    imul eax, x  // eax = a^2 * x

    //    // добавление a^2 * x к промежуточному результату
    //    add ecx, eax // ecx = (x^2 - a*x) / (b + 2) - x^3 / 3 + a^2 * x

    //    // сохранение результата
    //    mov result, ecx

    //    // восстановление регистров
    //    pop edx
    //    pop ecx
    //    pop ebx
    //    pop eax
    //}

    //printf("y: %d\n", result);
    //_getch();
    //return 0;


    // 2 задача 

    //int num1 = 5, num2 = 3; 
    //int min;

    //__asm
    //{
    //    // сохранение регистров
    //    push eax
    //    push ebx

    //    // загрузка num1 и num2 в регистры
    //    mov eax, num1
    //    mov ebx, num2

    //    // сравнение num1 и num2
    //    cmp eax, ebx
    //    jle num1_less_equal // если num1 <= num2, перейти к num1_less_equal
    //    mov min, ebx // иначе, min = num2
    //    jmp done

    //    num1_less_equal :
    //    mov min, eax // min = num1

    //        done :
    //    // восстановление регистров
    //    pop ebx
    //        pop eax
    //}

    //printf("min: %d\n", min);
    //_getch();
    //return 0;

    // 3 задача

    //int sum = 0;

    //__asm
    //{
    //// сохранение регистров
    //push eax
    //push ebx

    //// начальное значение -98
    //mov eax, -98

    //calculate_sum:
    //// добавление числа к сумме
    //add sum, eax

    //    // увеличение на 2 (переход к следующему четному числу)
    //    add eax, 2

    //    // если eax меньше или равно -2, продолжаем цикл
    //    cmp eax, -2
    //    jle calculate_sum

    //    // восстановление регистров
    //    pop ebx
    //    pop eax
    //}

    //printf("sum: %d\n", sum);
    //_getch();
    //return 0;

    // 4 задача

//    int array[10] = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 }; // Пример массива
//    int A = 15; // Заданное число
//    int found = 0; // Флаг для обозначения нахождения пары
//
//    __asm
//{
//    // Сохранение регистров
//    push eax
//    push ebx
//    push ecx
//    push edx
//
//    // Установка индекса на начало массива
//    mov ecx, 0
//
//    check_next_pair:
//    // Проверка условия выхода из цикла (если индекс больше 8, т.к. проверяем соседние пары)
//    cmp ecx, 8
//        jg done
//
//        // Загрузка элементов массива в регистры
//        mov eax, array[ecx * 4]
//        mov ebx, array[ecx * 4 + 4]
//
//        // Суммирование соседних элементов
//        add eax, ebx
//
//        // Сравнение суммы с заданным числом A
//        cmp eax, A
//        je found_pair
//
//        // Переход к следующей паре
//        inc ecx
//        jmp check_next_pair
//
//        found_pair :
//    // Установка флага нахождения пары
//    mov found, 1
//
//        done :
//        // Восстановление регистров
//        pop edx
//        pop ecx
//        pop ebx
//        pop eax
//    }
//
//    if (found)
//    {
//        printf("sum %d, found.\n", A);
//    }
//    else
//    {
//        printf("sum %d, not found.\n", A);
//    }
//    _getch();
//    return 0;


    // 5 задача 
    
    
     // Размер массива
    const int n = 4;
    int array[n][n] = 
    {
        {1, 2, 3, 4},    
        {5, 6, 7, 8},
        {9, 10, 11, 12},
        {13, 14, 15, 16}
    };

    // Заменяем максимальный элемент каждой строки на ноль
    for (int i = 0; i < n; ++i) {
        int max_element = array[i][0];  // Предполагаем, что первый элемент строки - максимальный
        int max_index = 0;              // Индекс максимального элемента
        for (int j = 1; j < n; ++j) {
            if (array[i][j] > max_element) {
                max_element = array[i][j];  // Найден новый максимальный элемент
                max_index = j;              // Запоминаем его индекс
            }
        }
        array[i][max_index] = 0;  // Заменяем максимальный элемент на ноль
    }

    // Меняем местами второй и предпоследний столбцы
    for (int i = 0; i < n; ++i) {
        int temp = array[i][1];           // Сохраняем значение второго элемента
        array[i][1] = array[i][n - 2];   // Копируем значение из предпоследнего элемента во второй
        array[i][n - 2] = temp;          // Восстанавливаем значение второго элемента из временной переменной
    }

    // Выводим измененный массив
    printf("Modified array:\n");
    for (int i = 0; i < n; ++i) {
        for (int j = 0; j < n; ++j) {
            printf("%d ", array[i][j]);  // Выводим элементы массива
        }
        printf("\n");  // Переход на новую строку для вывода следующей строки массива
    }
    _getch();
    return 0;
}
    



// Запуск программы: CTRL+F5 или меню "Отладка" > "Запуск без отладки"
// Отладка программы: F5 или меню "Отладка" > "Запустить отладку"

// Советы по началу работы 
//   1. В окне обозревателя решений можно добавлять файлы и управлять ими.
//   2. В окне Team Explorer можно подключиться к системе управления версиями.
//   3. В окне "Выходные данные" можно просматривать выходные данные сборки и другие сообщения.
//   4. В окне "Список ошибок" можно просматривать ошибки.
//   5. Последовательно выберите пункты меню "Проект" > "Добавить новый элемент", чтобы создать файлы кода, или "Проект" > "Добавить существующий элемент", чтобы добавить в проект существующие файлы кода.
//   6. Чтобы снова открыть этот проект позже, выберите пункты меню "Файл" > "Открыть" > "Проект" и выберите SLN-файл.
